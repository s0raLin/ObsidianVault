## WebSockets

WebSockets 在单个长期连接上提供**全双工通信通道**。这意味着客户端和服务器可以随时发送消息，而无需为每条消息建立新的连接。

下面是 WebSockets 的工作流程概述：

1. 客户端发起请求，要求将协议从 HTTP 升级为 WebSocket。该请求通过 HTTP 头部中的 `Upgrade` 和 `Sec-WebSocket-Key` 字段传达。
2. 如果服务器支持升级，它会返回 `HTTP 101` 状态码（表示“协议切换”），并附带 `Sec-WebSocket-Accept` 头部以确认握手成功。
3. 握手完成后，通信协议从 HTTP 切换为 WebSocket，从而建立一个持久的双向通信通道。

### 优点

- 支持全双工通信，服务器和客户端可以同时发送和接收数据。
- 持久连接减少了重复建立连接的开销，消息延迟极低。
- 适用于多种应用，如聊天服务、在线游戏、金融交易平台等。
- 被大多数现代浏览器支持。

### 局限性

- 相比 SSE 和长轮询，实现和管理更复杂。
- 服务器维护大量 WebSocket 连接具有挑战性。
- 某些防火墙或代理服务器可能会阻止 WebSocket 连接。
- 需要注意安全问题，例如跨站 WebSocket 劫持。

---

## 长轮询（Long Polling）

长轮询是一种 Web 通信技术，通过保持更持久的连接，使服务器能够向客户端传输实时数据。其工作方式如下：

1. 客户端向服务器发送 HTTP 请求，请求最新信息。
2. 服务器不会立即响应，而是保持请求打开，等待新数据出现或达到超时时间。
3. 一旦有新数据或超时发生，服务器就向客户端返回响应（新数据或无更新通知）。
4. 客户端收到响应后处理数据，并立即发起新的长轮询请求。

这一循环使客户端能够持续检查更新，而不需要频繁地轮询。

---

### Node.js + Express 长轮询示例

#### 服务端实现

创建一个简单的 Express 服务器，包含两个端点：

- `/poll` 用于长轮询
- `/messages` 用于发送新消息

（代码保持原样）

**代码说明：**  
服务器会持续检查是否有新消息。如果没有，它就等待；一旦有新消息，就立即返回给客户端。

---

#### 客户端实现

客户端使用 Fetch API 持续向 `/poll` 端点发送请求。

（代码保持原样）

**代码说明：**  
客户端发起长轮询请求，服务器等待新数据再返回。客户端收到数据后立即再次请求，从而持续接收更新。如果发生错误（例如网络问题），客户端会等待 5 秒再重试，以避免频繁请求服务器。

---

长轮询适用于更新不频繁的应用场景，在这种情况下使用 WebSockets 或 SSE 可能并不划算。

### 优点

- 比 WebSockets 更容易在服务器端实现。
- 与大多数浏览器和代理兼容。

### 局限性

- 资源效率较低，每次事件都需要新的 HTTP 连接。
- 只能由客户端发起通信。
- 可能存在延迟，因为服务器需要等待数据后才响应。
- 难以扩展，需要管理大量连接。

---

## 服务器发送事件（Server-Sent Events，SSE）

SSE 允许服务器通过单个**单向连接**向客户端推送更新。

工作流程如下：

1. 客户端通过普通 HTTP 请求连接服务器。
2. 服务器返回响应，并将 `Content-Type` 设置为 `text/event-stream`。
3. 服务器保持连接打开，并周期性发送包含事件类型和数据的消息。
4. 客户端监听这些事件并进行处理。

---

SSE 特别适用于：

- 实时通知
- 实时文本流
- 社交媒体动态更新
- 所有需要服务器主动推送数据的场景

---

### 优点

- 协议简单，比 WebSockets 更容易实现。
- 非常适合服务器 → 客户端的单向数据流。
- 连接断开后浏览器会自动重连。
- 使用单个 TCP 连接，减少 HTTP 请求开销。

### 局限性

- 不支持双向通信。
- Internet Explorer 和部分旧浏览器不支持。
- 只能处理文本数据，不能传输二进制数据。