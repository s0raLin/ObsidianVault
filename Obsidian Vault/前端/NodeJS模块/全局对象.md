NodeJS提供了一些预定义的全局对象，你可以在应用程序的任何地方访问
**Node.js的全局作用域**和**浏览器的顶级作用域**是不同的


## Node.js的全局对象
Node.js中的全局对象非常有用:
* 文档完善、行为稳定
* 为常见问题提供了标准解决方案
* 与其他模块具有良好的兼容性和支持
* 使用方便，无需显式`import`或`require`

## JavaScript对象的全局性
例如，你在浏览器和Node.js中都可以使用的`console`全局对象,通过`log`方法向控制台输出内容
```js
console.log("Hello!"); // Hello!
```

## Node.js中默认的全局对象
可以在任何模块中直接访问，例如：
* `String`
* `Array`
* `Math`
* `Date`

```js
const myString = 'Hello!';
console.log(myString.toUpperCase());
// 输出：HELLO!
```

**解释代码**  
上面的示例使用了 `toUpperCase()` 方法。  
`toUpperCase()` 属于 `String` 全局对象的方法，因此不需要导入或显式声明 `String`。

## Node.js和浏览器作用域的区别

### JavaScript 顶级作用域

**顶级作用域（top-level scope）** 是指程序或模块最外层的作用域，即不被任何其他作用域包裹的地方。

### 浏览器中的顶级作用域

在浏览器中，顶级作用域通常就是**全局作用域**：
- 顶级定义的变量和函数会被挂载到 `window` 对象上
- 可以通过 `window.xxx` 在任意位置访问

```js
// 浏览器脚本
var browserVar = 'Hello from the browser!';

console.log(browserVar);
// 输出：Hello from the browser!

console.log(window.browserVar);
// 输出：Hello from the browser!
```

### Node.js 中的顶级作用域

在 Node.js 中：

- **每个文件都是一个独立的模块**
    
- 模块的顶级作用域 **不会绑定到 `global` 对象**
    
- 顶级变量只在当前模块内可用
```js
// Node.js 模块
const nodeVar = 'Hello from Node.js!';

console.log(nodeVar);
// 输出：Hello from Node.js!

console.log(global.nodeVar);
// 输出：undefined
```


**解释代码**  
`nodeVar` 只存在于当前模块中，并不会自动成为全局变量。

如果你希望在多个模块之间共享变量或函数，必须通过 `module.exports` 或 `exports` 显式导出。

---

## __dirname 和 __filename

`__dirname` 和 `__filename` 是 **Node.js 独有的全局对象**：

- 只能在 Node.js 环境中使用
    
- 浏览器中不可用
    
- 常用于处理文件路径
    

它们的作用：

- `__filename`：当前模块的**完整文件路径**
    
- `__dirname`：当前模块所在的**目录的绝对路径**

```js
// index.js
console.log(__dirname);
// 输出：/Users/username/Documents/projects

console.log(__filename);
// 输出：/Users/username/Documents/projects/index.js
```


**解释代码**

- `__dirname` 返回当前文件所在目录的绝对路径
    
- `__filename` 返回当前文件的完整路径（包含文件名）
    

这在进行文件读写操作时非常有用，可以避免路径错误。

---

## global 对象

`global` 是 Node.js 中的**全局对象**，类似于浏览器中的 `window`，但有以下不同：

- `global` 在任何模块、任何函数中都可访问
    
- 浏览器中的 `window` 只存在于浏览器环境
    

你可以通过以下代码查看 `global` 中默认包含的内容：

```js
console.log(global);
```

输出中可以看到一些熟悉的函数和对象，例如：

- `setTimeout`
- `setInterval`
- `fetch`
- `performance`
- `console`

---

### console 也是 global 的一部分

```js
console.log('Hello');
global.console.log('Hello');

// 输出：
// Hello
// Hello
```

**解释代码**  
`console` 是 `global` 对象的属性，因此两种写法是等价的。

---

### 使用 global 定义全局变量（不推荐）

```js
global.myVar = "Hello, world!";

console.log(myVar);
// 输出：Hello, world!
```

**解释代码**  
通过 `global` 定义的变量可以在整个应用中访问。

⚠️ **不推荐这样做**，因为：

- 容易造成命名冲突
- 增加代码耦合度
- 降低可维护性

更好的做法是使用：

- 模块化
- 局部变量
- 函数参数传递

---

## require()、module 和 exports

### require()

`require()` 是 Node.js 的全局函数，用于加载模块：

```js
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```


### module 和 module.exports

`module` 对象包含当前模块的信息，例如：

- 文件路径
- 模块 ID
- 导出的内容

⚠️ `module` 并不是真正意义上的全局对象，它是**当前模块的私有引用**。

```js
// math.js
const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

module.exports = { add, multiply };
```

在其他模块中使用：
```js
const math = require('./math.js');

console.log(math.add(3, 2));      // 5
console.log(math.multiply(3, 3)); // 9
```

### exports（module.exports 的简写）

`exports` 是 `module.exports` 的引用，可以简写导出：

```js
// greetings.js
exports.sayMeow = () => console.log('Meow!');
exports.sayBark = () => console.log('Bark!');
```


### 模块缓存机制

Node.js 的模块 **在第一次加载后会被缓存**：
- 多次 `require()` 同一个模块，只会执行一次
- 后续加载直接使用缓存结果
- 导出的状态不会自动更新

